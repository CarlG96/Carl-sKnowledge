The Factory and Abstract Factory Design patterns are some of the most famous and most used design patterns, there are however quite a few different ways of thinking about the design pattern. One thing that is common across all variations is that they move the construction of an object into a 'factory' (either a separate class or a method of a group of classes) so that dependency injection can be used and code can be modified easily in inheritance/ implementation relationships. All factory variants are creational design patterns.

## Abstract Factory Design Pattern
Let's suppose you are creating a fantasy video game. You know that the game will require the enemy types of Warrior, Ninja and Wizard to represent enemies in the game. You also know that each of these enemy types will have the variants Human, Troll and Orc, to represent the race of the enemy in the game. In order to do this, you would first create three interfaces for Warrior, Ninja and Wizard respectively. From these instances you would create the variants: HumanWarrior, TrollWarrior, OrcWarrior, HumanNinja, TrollNinja, OrcNinja, HumanWizard, TrollWizard and OrcWizard.

You would then create an EnemyType factory, an abstract interface which would have three methods: CreateWarrior(), CreateNinja() and CreateWizard(). Then you would create three implementations from this: HumanEnemyFactory, TrollEnemyFactory and OrcEnemyFactory. Your client code could then call on any of these factories in the same way with the same methods but if you decided you wanted to add a fourth factory, say a LizardManFactory, then it could easily be dependency injected in without changing the rest of the code.

## Factory Method Design Pattern

Suppose in the same fantasy video game you need to create player types of Knight, Archer and Cleric. You could new them up whenever you want them, but new is glue and prevents dependency injection and means you'd need to edit multiple instances of code in order to make a change. Instead you could have a PlayerCreator interface (the factory) with a Player interface(the product). Any implementation of the PlayerCreator interface would have the method CreateCharacter, but each variant would return a different sort of player type. So a KnightCreator would return a Knight, an ArcherCreator would return an Archer, a ClericCreator would return a Cleric etc.


## Factory Switch Case Variant Pattern
Suppose at the start of the same fantasy video game you need the player to choose which elemental powers they have. They have the options of Fire, Water, Wind or Earth. You could write a massive if statement to new up each different class depending on the inputted choice, but that would look messy. Instead, you could create an ElementalPowerFactory that returns the Elemental Power of your player character. Here, the object of the factory would have a method called CreateElementalPower() which would take an argument of the ElementalType enum. Once provided, the factory will handle the creation of the new object. This variant is good for cleaning up your code, especially if you have many different variants that are needed or if you want to extend the options available. Using this version of the factory, if you decided the player could also choose from the elements Ice, Lightning, Poison, Hope and Bubblegum you could encapsulate it entirely within the ElementalPowerFactory without having to change the logical flow of your code.